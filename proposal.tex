\documentclass{article}
\usepackage{graphicx}

\begin{document}

\title{Independent Study: Multiprocessor Weenix}
\author{Eric Caruso, Jackson Owens}
\maketitle

\section{Motivation}

Computers and even mobile devices are increasingly shipping with multiple cores. Any modern
operating system must be able to take advantage of all available processors. While modern
operating systems support running on all cores, many use coarse-grained mutual exclusion 
within the kernel to protect its data structures from synchronization issues. With this
approach, no actual parallelism is achieved within kernel tasks. Applying lock-free and 
wait-free algorithms to the kernel would allow parallelism in an operating system's own
tasks.

\section{Overarching goals}

\begin{itemize}
    \item Learn and implement wait-free and lock-free algorithms and data structures
    \item Port Weenix to run on a multiprocessor
\end{itemize}

\section{Synchronization constructs}

We'll need to build up a library of synchronization constructs to use across the kernel. Many of
the data structures deeply embedded within Weenix, such as {\tt{list\_t}}, will need to be
replaced with concurrent versions.

\subsection{Hardware instruction abstractions}

To implement locks, wait-free and lock-free data structures, we'll need to use synchronization 
hardware instructions like x86's {\tt{CMPXCHG}}. To avoid littering inline assembly everywhere,
we'll create a library of wrappers around these synchronization instructions.

\subsection{Concurrent data structures}

\end{document}
