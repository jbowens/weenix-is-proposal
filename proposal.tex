\documentclass{article}
\usepackage{graphicx}

\begin{document}

\title{Independent Study: Multiprocessor Weenix}
\author{Eric Caruso, Jackson Owens}
\maketitle

\section{Motivation}

Computers and even mobile devices are increasingly shipping with multiple cores. Any modern
operating system must be able to take advantage of all available processors. While modern
operating systems support running on all cores, many use coarse-grained mutual exclusion 
within the kernel to protect its data structures from synchronization issues. %DISCLAIMER: Might not be true.

This approach ensures concurrent safety but achieves no actual parallelism within kernel tasks. Applying 
lock-free and wait-free algorithms to the kernel would allow parallelism in an operating 
system's own tasks.

\section{Overarching goals}

\begin{itemize}
    \item Learn and implement wait-free and lock-free algorithms and data structures
    \item Port Weenix to run on a multiprocessor
\end{itemize}

\section{Synchronization constructs}

We'll need to build up a library of synchronization constructs to use across the kernel. Many of
the data structures deeply embedded within Weenix, such as {\tt{list\_t}}, will need to be
replaced with concurrent versions.

\subsection{Hardware instruction abstractions}

To implement locks, wait-free and lock-free data structures, we'll need to use synchronization 
hardware instructions like x86's {\tt{CMPXCHG}}. To avoid littering inline assembly everywhere,
we'll create a library of wrappers around these synchronization instructions.

\subsection{Concurrent data structures}

Many kernel data structures like wait queues and lists must be accessible from multiple
processors concurrently. We'll need to write concurrent versions of these data structures.

\begin{itemize}
    \item \textbf{Mutexes}\\
    Some resources, like the hard disk, will need to be protected through mutual exclusion. The current mutex
    implementation, {\tt{kmutex\_t}}, will not work on a multiprocessor. We'll need to implement
    spin locks and mutexes.
    \item \textbf{Concurrent queue}\\
    Queues are used throughout Weenix, mostly in the form of {\tt{ktqueue\_t}} wait queues. We can
    use known algorithms for wait-free queues (Kogan, Petrank) and more practical lock-free queues (Michael, Scott) 
    \item \textbf{Concurrent list}\\
    Lists are everywhere in Weenix. Both lock-free and wait-free algorithms exist for linked lists.
    \item \textbf{Concurrent hash table or skip list}\\
    In Weenix page frames are looked up through a hash table. Algorithms exist for fast, concurrent hash tables. Or,
    we might be able to simplify things and instead use a concurrent skip list.
\end{itemize}

\section{Porting weenix}

Weenix is large enough that we should port incrementally. We can disable everything from kern 2 up, and follow the same
trajectory as 169, renabling parts of the operating system as we port.

\subsection{Subsystems and Kern 1}

The boot sequence must start the extra cores as appropriate. Slab allocators must be reworked to be SMP-safe,
and we would like to achieve this by using lock-free algorithms. The scheduler must also be changed. Since we
are implementing kernel preemption, we are going to need to use priority, and the scheduler will need to take
this into account as well. We will also need to change the page frame subsystem at this point, because
the page frames are needed to put the kernel at the proper location in virtual memory. TLB shootdown will also
need to be implemented.

The single-processor, cooperative design of the Weenix kernel is fairly baked in, but we are confident that
we can change it.

\subsection{Kern 2 and Beyond}

Our implementations of the projects from here on usually made use of the same single-processor, cooperative
assumption, and will need more elaborate locking schemes, because there is now no guarantee that we can
execute specific contiguous statements without other things happening in between.

\end{document}
