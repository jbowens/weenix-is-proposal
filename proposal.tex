\documentclass{article}
\usepackage{graphicx}

\begin{document}

\title{Independent Study: Multiprocessor Weenix}
\author{Eric Caruso, Jackson Owens}
\maketitle

\section{Motivation}

Computers and even mobile devices are increasingly shipping with multiple cores. Any modern
operating system must be able to take advantage of all available processors. While modern
operating systems support running on all cores, many use coarse-grained mutual exclusion 
within the kernel to protect its data structures from synchronization issues. %DISCLAIMER: Might not be true.

This approach ensures concurrent safety but achieves no actual parallelism within kernel tasks. Applying 
lock-free and wait-free algorithms to the kernel would allow parallelism in an operating 
system's own tasks.

\section{Overarching goals}

\begin{itemize}
    \item Learn and implement wait-free and lock-free algorithms and data structures
    \item Port Weenix to run on a multiprocessor
\end{itemize}

\section{Synchronization constructs}

We'll need to build up a library of synchronization constructs to use across the kernel. Many of
the data structures deeply embedded within Weenix, such as {\tt{list\_t}}, will need to be
replaced with concurrent versions.

\subsection{Hardware instruction abstractions}

To implement locks, wait-free and lock-free data structures, we'll need to use synchronization 
hardware instructions like x86's {\tt{CMPXCHG}}. To avoid littering inline assembly everywhere,
we'll create a library of wrappers around these synchronization instructions.

\subsection{Concurrent data structures}

Many kernel data structures like wait queues and lists must be accessible from multiple
processors concurrently. We'll need to write concurrent versions of these data structures.

\begin{itemize}
    \item \textbf{Mutexes}\\
    Some resources, like the hard disk, will need to be protected through mutual exclusion. The current mutex
    implementation, {\tt{kmutex\_t}}, will not work on a multiprocessor. We'll need to implement
    spin locks and mutexes.
    \item \textbf{Concurrent queue}\\
    Queues are used throughout Weenix, mostly in the form of {\tt{ktqueue\_t}} wait queues. We can
    use known algorithms for wait-free queues (Kogan, Petrank) and more practical lock-free queues (Michael, Scott) 
    \item \textbf{Concurrent list}\\
    Lists are everywhere in Weenix. Both lock-free and wait-free algorithms exist for linked lists.
    \item \textbf{Concurrent hash table or skip list}\\
    In Weenix page frames are looked up through a hash table. Algorithms exist for fast, concurrent hash tables. Or,
    we might be able to simplify things and instead use a concurrent skip list.
\end{itemize}

\end{document}
